#!/usr/bin/env bash

# nf_configs
#
#USAGE:
#  ./nf_configs --help
#
#DESCRIPTION:
#  A script for checking the output from the neurofield repo's .conf files
#  against their expected output. The expected output is stored in the directory
#    ./test/data/configs/
#  The script also supports updating those expected output files when code or
#  .conf file changes have been made that intentionally modify the output.
#
# Author: Stuart A. Knock
# Originally Written: 2016-11-23
#

#Capture args the script was called with.
INPUTARG1="$1" ; INPUTARG2="$2"
#Make them read-only so we can't accidentally modify them.
declare -r  INPUTARG1 INPUTARG2

#Check we were called with the right number of args:
(($# > 2)) && { printf '%s\n' "${BASH_SOURCE[0]} takes at most 2 args" ; exit 1 ; }

SCRIPTDIR="$(dirname "${BASH_SOURCE[0]}")"

neurofield_exists(){
  if [[ -e "$SCRIPTDIR"/bin/neurofield ]]; then
    return 0
  else
    printf '%s\n' "The neurofield executable doesn't exist, run make."
    return 1
  fi
}

#Run appropriate functions based on how we were called.
parse_command_flags(){
  #check for command line switches
  case "$INPUTARG1" in
    --regenerate|-r)
      neurofield_exists || return 1
      regenerate_output_file "$INPUTARG2"
      return "$?"
    ;;
    --check|-c)
      neurofield_exists || return 1
      check_output_file "$INPUTARG2"
      return "$?"
    ;;
    --clean)
      #Remove files left around by calls to --check that found differences.
      rm -f /tmp/neurofield_*
      return "$?"
    ;;
    --help|-h|-?)
      msg_help
      return 0
    ;;
  esac
  printf '%s\n' "Unrecognised command line switch: $INPUTARG1"
  return 1
}

msg_help(){
  printf '\n %s\n' "Usage:"
  printf '   %s\n\n' "nf_configs --<mode> '<config_file>'"
  printf ' %s\n' "Modes:"
  printf '\n%s\n' "  --check"
  printf '%s\n'   "    Check if the output from neurofield has changed for a specified config file."
  printf '%s\n'   "    eg: ./nf_configs --check 'example'"
  printf '%s\n'   "    eg: ./nf_configs --check './configs/example.conf'"
  printf '\n%s\n' "  --regenerate"
  printf '%s\n'   "    Regenerates the output for the specified config file. This should only be"
  printf '%s\n'   "    used when you've intentionally made a change to the code or config file"
  printf '%s\n'   "    that should change the output. The updated output file should then be"
  printf '%s\n'   "    committed as part of the pull request for the code changes that caused the"
  printf '%s\n'   "    output to change."
  printf '%s\n'   "    eg: ./nf_configs --regenerate 'example'"
  printf '%s\n'   "    eg: ./nf_configs --regenerate './configs/example.conf'"
  printf '\n%s\n' "  --clean"
  printf '%s\n'   "    Removes files that are left in the /tmp/ directory when a call to --check"
  printf '%s\n'   "    finds differences."
  printf '%s\n'   "    eg: ./nf_configs --clean"
  printf '\n%s\n' "  --help"
  printf '%s\n'   "    Displays this message"
  printf '%s\n\n'   "    eg: ./nf_configs --help"
}

#Sets the global variable OUTPUT_FILE to the default location for the
#specified configuration file.
set_output_file(){
  local config_file="$1"

  #Set the default output file path for the current config file.
  OUTPUT_FILE="$SCRIPTDIR/test/data/configs/${config_file#*/configs/*}"
  OUTPUT_FILE="${OUTPUT_FILE%.*}.output"

}

# Run the config file provided as an argument, the first arg is expected
# to be a relative(to neurofield) path to the config file.
run_config(){
  local config_file="$1"
  local output_file
  local neurofield_status

  #If run_config() was called with a second arg use it as the output_file 
  if (( $# > 1 )); then
    output_file="$2"
  else #otherwise use the default location in the test directory
    output_file="$OUTPUT_FILE"
    local output_dir
    output_dir="$(dirname "$output_file")"
    #If it doesn't already exist: Create the output directory.
    [[ -d "$output_dir" ]] || mkdir --parents "$output_dir"
  fi
  
  #Run neurofield for the requested config file
  "$SCRIPTDIR/bin/neurofield" -i "$config_file" -o "$output_file"
  neurofield_status="$?"

  #If the run was successful then gzip the resulting file.
  ((neurofield_status == 0)) && gzip --force "$output_file"
  
  return "$neurofield_status"
}

#Creates an output file in ./test/data/configs/ corresponding to the specified .conf file.
regenerate_output_file(){
  local config_file="$1"
  if [[ "$config_file" == "all" ]]; then
    #NOTE: currently restricting the search for conf files to a max-depth of 2 to avoid
    #      running the conf files from Abeysuriya_2014, as they generate GB of output.
    local -a config_files
    config_files=($(find "$SCRIPTDIR/configs" -maxdepth 2 -type f -name '*.conf'))
    for (( i = 0; i < ${#config_files[@]}; i++ )) ; do
      set_output_file "${config_files[i]}"
      run_config "${config_files[i]}"
    done
    return 0
  fi
  if [[ ! -f "$config_file" ]]; then
    config_file="$(find "$SCRIPTDIR/configs" -maxdepth 3 -type f -name "${config_file}.conf")"
  fi
  if [[ -f "$config_file" ]]; then
    set_output_file "$config_file"
    run_config "$config_file"
    return "$?"
  else
    printf '%s\n' "You need to specify which config file to regenerate output for."
    printf '%s\n' "eg. nf_configs --regenerate 'example'"
    printf '%s\n' "or nf_configs --regenerate './configs/example.conf'"
  fi
  return 1
}

#Generates a temporary output file in /tmp/ for a specified config file and
#compares it to the corresponding output file in neurofield/test/data/configs/
check_output_file(){
  local config_file="$1"
  local config_file_name
  local diff_status
  if [[ ! -f "$config_file" ]]; then
    config_file="$(find "$SCRIPTDIR/configs" -maxdepth 3 -type f -name "${config_file}.conf")"
  fi
  if [[ -f "$config_file" ]]; then
    set_output_file "$config_file"
    [[ -f "${OUTPUT_FILE}.gz" ]] || { printf '%s\n' "No existing file to check against."; exit 1; }
    config_file_name="$(basename "$config_file")"
    output_file_tmp="$(mktemp --tmpdir="/tmp" --suffix=.output neurofield_"$config_file_name"-XXXX)"
    run_config "$config_file" "$output_file_tmp"
    zdiff "${output_file_tmp}.gz" "${OUTPUT_FILE}.gz"  &> /dev/null
    diff_status="$?" #NOTE: No-diff = 0; diff = 1; error = 2
    case "$diff_status" in
      0)
        printf '%s\n' "$config_file output hasn't changed."
        rm -f "${output_file_tmp}.gz"
    ;;
      1)
        zdiff --side-by-side --suppress-common-lines --width=180 "${OUTPUT_FILE}.gz" "${output_file_tmp}.gz" | less
        printf '%s\n' "$config_file output DIFFERS!"
        printf '%s\n' "See: ${output_file_tmp}.gz"
    ;;
      2)
        printf '%s\n' "Error while running diff."
    ;;
    esac
    return "$diff_status"
  else
    printf '%s\n' "You need to specify which config file to regenerate output for."
    printf '%s\n' "eg. nf_configs --regenerate 'example'"
  fi
  return 1
}

#The function run when the script is called
main(){
  parse_command_flags
  exit "$?"
}

#Run the script's main function.
main
