#!/usr/bin/env bash

# nf_benchmarks:
#    A script for benchmarking neurofield and storing the results.
#
#USAGE:
#  #Show this header message:
#  nf_benchmarks --help
#
#  #Benchmark a specific configuration file.
#  nf_benchmarks <config_filename>
#
#  #Benchmark a specific configuration file with output to memory.
#  #This only works under Linux as it makes use of /dev/shm.
#  nf_benchmarks --to-mem <config_filename>
#
#  #Benchmark a specific configuration file using a non-default compiler.
#  nf_benchmarks --clang <config_filename>
#
#  #Benchmark all .conf files in the benchmarks directory.
#  nf_benchmarks
#
#  #Benchmark all .conf files in ./benchmarks with output to memory.
#  nf_benchmarks --to-mem
#
#REQUIRES:
#  /usr/bin/time
#
#DESCRIPTION:
#  The nf_benchmarks script can run either a specified .conf file or
#  all .conf files stored in the benchmarks directory
#    ./benchmarks/
#  The script stores timing and configuration information for simulation
#  runs in the directory:
#    ./benchmarks/results
#  Timing information is obtained using /usr/bin/time. Information is
#  stored in both a "human-readable" format in 'timings_*' files as well
#  as a pseudo database format in four .csv files:
#      + ./benchmarks/results/simulation_resources.csv
#      + ./benchmarks/results/simulation_conf.csv
#      + ./benchmarks/results/code_info.csv
#      + ./benchmarks/results/system_info.csv
#  The script expects/requires:
#      + to be run from a clean clone of neurofield's repository
#        (clean here means no uncommitted changes in the working directory);
#      + neurofield to be building and running properly; and
#      + valid configuration files as input.
#
# Authors: Paula Sanz-Leon; Stuart A. Knock;
#
#Use the header as a basic help message.
[[ "$1" =~ ^('-h'|'--help')$ ]] && { head -n $((LINENO-4)) "${BASH_SOURCE[0]}"; exit 1; }

DEBUG='false'


#--------------------------------------------------------------#
#--------------- Initialise the Where and When ----------------#
#--------------------------------------------------------------#

TMP_DIR='/tmp'
MEM_DIR='/dev/shm'
SCRIPT_PATH="$( cd "$(dirname "${BASH_SOURCE[0]}")" || exit 1 ; pwd -P )"
RESULTS_DIR="${SCRIPT_PATH}/results"
NEUROFIELD_DIR="$( cd "$SCRIPT_PATH" || exit 1; cd ../ || exit 1; pwd -P )"
NEUROFIELD="$NEUROFIELD_DIR/bin/neurofield"

#If the results directory does not exist, create it.
if [ ! -d "$RESULTS_DIR"; then
  printf 'WARNING: %s\n' "'$RESULTS_DIR' does not exist. Will create it"
  mkdir "$RESULTS_DIR"
fi

TODAY="$(date +%F)"  #Date in IEEE standard format, ie YYYY-mm-dd
SCRIPT_START_TIME="$(date +%H:%M:%S)" #Time in a readable IEEE standard format, ie HH:MM:SS
FILE_NAME_NOW="$(date +%FT%H%M%S)"  #ISO 8601: YYYY-mm-ddThhMMSS


#--------------------------------------------------------------#
#---------------------- Parse Arguments -----------------------#
#--------------------------------------------------------------#

#Capture command line arguments
INPUT_ARG1="$1"
INPUT_ARG2="$2"
INPUT_ARG3="$3"
INPUT_ARG4="$4"
INPUT_ARG5="$5"

if [[ "${DEBUG,,}" = 'true' ]]; then
  printf '%s\n' "Number of args: '$#'"
  printf '%s\n' "INPUT_ARG1: '$INPUT_ARG1'"
  printf '%s\n' "INPUT_ARG2: '$INPUT_ARG2'"
  printf '%s\n' "INPUT_ARG3: '$INPUT_ARG3'"
  printf '%s\n' "INPUT_ARG4: '$INPUT_ARG4'"
  printf '%s\n' "INPUT_ARG5: '$INPUT_ARG5'"
fi

#Delete the last N benchmarks we added, useful when something goes wrong with benchmark run.
if [[ "$1" =~ ^('--delete')$ ]]; then
  number_to_delete="$2"
  #TODO: consider validating our benchmark-db, eg entry_count should be same for all 4 files.
  entry_count="$(wc --lines < "$SCRIPT_PATH/results/simulation_resources.csv")"
  keep=$((entry_count-number_to_delete))
  if ((keep >= 1)); then
    head -n "$keep" "$SCRIPT_PATH/results/simulation_resources.csv" > "$TMP_DIR/nf_simulation_resources.csv"
    head -n "$keep" "$SCRIPT_PATH/results/simulation_conf.csv"      > "$TMP_DIR/nf_simulation_conf.csv"
    head -n "$keep" "$SCRIPT_PATH/results/code_info.csv"            > "$TMP_DIR/nf_code_info.csv"
    head -n "$keep" "$SCRIPT_PATH/results/system_info.csv"          > "$TMP_DIR/nf_system_info.csv"
    [[ -s "$TMP_DIR/nf_simulation_resources.csv" ]] && mv "$TMP_DIR/nf_simulation_resources.csv" "$SCRIPT_PATH/results/simulation_resources.csv"
    [[ -s "$TMP_DIR/nf_simulation_conf.csv"      ]] && mv "$TMP_DIR/nf_simulation_conf.csv"      "$SCRIPT_PATH/results/simulation_conf.csv"
    [[ -s "$TMP_DIR/nf_code_info.csv"            ]] && mv "$TMP_DIR/nf_code_info.csv"            "$SCRIPT_PATH/results/code_info.csv"
    [[ -s "$TMP_DIR/nf_system_info.csv"          ]] && mv "$TMP_DIR/nf_system_info.csv"          "$SCRIPT_PATH/results/system_info.csv"
    exit 0
  else
    printf '%s\n' "ERROR: --delete called with >= number-of-entries."
    exit 1
  fi
fi

if [[ '--to-mem' =~ ^("$INPUT_ARG1"|"$INPUT_ARG2"|"$INPUT_ARG3"|"$INPUT_ARG4"|"$INPUT_ARG5")$ ]]; then
  [[ "$(uname)" = 'Linux' ]] || { printf 'ERROR: %s\n' 'Flag --to-mem is only configured for Linux.'; exit 1; }
  NF_BENCH_TO_MEM='true'
fi
if [[ '--no-make' =~ ^("$INPUT_ARG1"|"$INPUT_ARG2"|"$INPUT_ARG3"|"$INPUT_ARG4"|"$INPUT_ARG5")$ ]]; then
  NF_BENCH_NO_MAKE='true'
fi
if [[ '--clang' =~ ^("$INPUT_ARG1"|"$INPUT_ARG2"|"$INPUT_ARG3"|"$INPUT_ARG4"|"$INPUT_ARG5")$ ]]; then
  COMPILER='clang'
elif [[ '--gcc' =~ ^("$INPUT_ARG1"|"$INPUT_ARG2"|"$INPUT_ARG3"|"$INPUT_ARG4"|"$INPUT_ARG5")$ ]]; then
  COMPILER='gcc'
fi
if [[ '--store-output' =~ ^("$INPUT_ARG1"|"$INPUT_ARG2"|"$INPUT_ARG3"|"$INPUT_ARG4"|"$INPUT_ARG5")$ ]]; then
  NF_BENCH_STORE_OUTPUT='true'
fi

NON_FLAG_ARG_COUNT=0
[[ -n "${INPUT_ARG1}" && "${INPUT_ARG1:0:1}" != '-' ]] && { ((++NON_FLAG_ARG_COUNT)); CONFIG_FILE="$INPUT_ARG1"; }
[[ -n "${INPUT_ARG2}" && "${INPUT_ARG2:0:1}" != '-' ]] && { ((++NON_FLAG_ARG_COUNT)); CONFIG_FILE="$INPUT_ARG2"; }
[[ -n "${INPUT_ARG3}" && "${INPUT_ARG3:0:1}" != '-' ]] && { ((++NON_FLAG_ARG_COUNT)); CONFIG_FILE="$INPUT_ARG3"; }
[[ -n "${INPUT_ARG4}" && "${INPUT_ARG4:0:1}" != '-' ]] && { ((++NON_FLAG_ARG_COUNT)); CONFIG_FILE="$INPUT_ARG4"; }
[[ -n "${INPUT_ARG5}" && "${INPUT_ARG5:0:1}" != '-' ]] && { ((++NON_FLAG_ARG_COUNT)); CONFIG_FILE="$INPUT_ARG5"; }


#--------------------------------------------------------------#
#----------------- Begin Function Definitions -----------------#
#--------------------------------------------------------------#

#Rebuild neurofield from scratch to make sure the executable matches current code.
fresh_build(){
  #Use a subshell to:
  (
    #Change into neurofield's base directory.
    if ! cd "$NEUROFIELD_DIR"; then
      printf 'ERROR: %s\n' "Failed to change to neurofield directory: '$NEUROFIELD_DIR'"
      return 1
    fi
    #Ensure we are actually running the current version of the code.
    make clean
    if [[ "$COMPILER" = 'clang' ]]; then
      make clang
    elif [[ "$COMPILER" = 'gcc' ]]; then
      make gcc
    else
      make
    fi
  )
  return 0
} # function fresh_build()

#Gather system information,
gather_system_info(){
  CALLER=$(whoami)
  PLATFORM="$(uname)"
  #CPU info
  CPU_MODEL_NAME="$(grep 'model name' '/proc/cpuinfo' | sort -u)"
  CPU_MODEL_NAME="$(sed 's/model name[[:blank:]]*: //' <<< "$CPU_MODEL_NAME")"
  CPU_CACHE_SIZE="$(grep 'cache size' '/proc/cpuinfo' | sort -u)"
  CPU_CACHE_SIZE="$(sed 's/cache size[[:blank:]]*: //' <<< "$CPU_CACHE_SIZE")"
  CPU_CORE_COUNT="$(grep 'cpu cores' '/proc/cpuinfo' | sort -u)"
  CPU_CORE_COUNT="$(sed 's/cpu cores[[:blank:]]*: //' <<< "$CPU_CORE_COUNT")"
  #Memory info
  RAM_TOTAL="$(grep 'MemTotal' '/proc/meminfo')"
  RAM_TOTAL="$(sed 's/MemTotal:[[:blank:]]*//' <<< "$RAM_TOTAL")"
  RAM_AVAILABLE="$(grep 'MemAvailable' '/proc/meminfo')"
  RAM_AVAILABLE="$(sed 's/MemAvailable:[[:blank:]]*//' <<< "$RAM_AVAILABLE")"
  RAM_FREE="$(grep 'MemFree' '/proc/meminfo')"
  RAM_FREE="$(sed 's/MemFree:[[:blank:]]*//' <<< "$RAM_FREE")"
  #NOTE: Looks like it will be a pain to reliably grab disk info.
  #Compiler info
  if [[ -z "$COMPILER" && "${PLATFORM,,}" = 'linux' ]]; then
    COMPILER='gcc'
  elif [[ -z "$COMPILER" && "${PLATFORM,,}" = 'darwin' ]]; then
    COMPILER='clang'
  fi
  COMPILER_VERSION="$($COMPILER --version | grep --only-matching '[[:digit:]]\.[[:digit:]]*\.\?[[:digit:]]* ' | tr -d ' ')"
  return 0
} # function gather_system_info()

#Gather code information,
gather_code_info(){
  git_status="$(git status --untracked-files=no --porcelain)"
  if [[ -n "$git_status" ]]; then
    printf 'ERROR: %s\n' 'The git repo you are in has uncommitted changes.'
    printf '    %s\n' 'Commit, stash or revert changes before running benchmarks.'
    return 1
  fi
  GIT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
  GIT_COMMIT="$(git rev-parse HEAD)"
  GIT_LATEST_RELEASE="$(git tag -l | tail -1)"
  return 0
} # function gather_code_info()

#Gather information from the .conf file.
gather_conf_info(){
  local time_conf=''
  time_conf="$(grep '^[[:space:]]*Time:' "$CONFIG_FILE")"
  SIMULATION_LENGTH="$(cut -d' ' -f2 <<< "$time_conf")"
  TIME_STEP_SIZE="$(cut -d' ' -f4 <<< "$time_conf")"

  NUMBER_OF_NODES="$(grep '^[[:space:]]*Nodes:' "$CONFIG_FILE" | sed 's/^[[:space:]]*Nodes:[[:space:]]*//')"

  local propagator_conf=''
  propagator_conf="$(grep '^[[:space:]]*Propagator[[:space:]]*[[:digit:]]' "$CONFIG_FILE")"
  NUMBER_OF_PROPAGATORS="$(tail -1<<< "$propagator_conf" | cut -d' ' -f2 |tr -d ':')"

  TAU=($(grep --only-matching 'Tau:.*' <<< "$propagator_conf" | cut -d' ' -f2))
  local tau
  MAX_TAU="${TAU[0]}"
  for tau in "${TAU[@]}" ; do
    [[ "$tau" > "$MAX_TAU" ]] && MAX_TAU="$tau"
  done
  return 0
} #function gather_conf_info()

#
write_db_entry(){
  #Add an entry to the Simulation Resource Information file -- csv.
  {
    printf '%s,' "$USER_TIME" "$USER_TIME_UNITS" "$MAX_RES_SIZE" "$MAX_RES_SIZE_UNITS" "$file_size_kb" 'kbytes'
    printf '%s\n' "$TODAY $SCRIPT_START_TIME"
  } >> "$RESULTS_DIR/simulation_resources.csv"
  #Add an entry to the System Information file -- csv.
  {
    printf '%s,' "$HOSTNAME" "$PLATFORM" "$CPU_MODEL_NAME" "$CPU_CACHE_SIZE" "$CPU_CORE_COUNT" "$RAM_TOTAL" "$RAM_FREE" "$RAM_AVAILABLE" "$CALLER" "$COMPILER" "$COMPILER_VERSION"
    printf '%s\n' "$TODAY $SCRIPT_START_TIME"
  } >> "$RESULTS_DIR/system_info.csv"
  #Add an entry to the Code Information file -- csv.
  {
    printf '%s,' "$GIT_BRANCH" "$GIT_COMMIT" "$GIT_LATEST_RELEASE"
    printf '%s\n' "$TODAY $SCRIPT_START_TIME"
  } >> "$RESULTS_DIR/code_info.csv"
  #Add an entry to the Simulation Configuration file -- csv.
  {
    printf '%s,' "$SIMULATION_LENGTH" "$TIME_STEP_SIZE" "$NUMBER_OF_NODES" "$NUMBER_OF_PROPAGATORS" "$MAX_TAU"
    printf '%s\n' "$TODAY $SCRIPT_START_TIME"
  } >> "$RESULTS_DIR/simulation_conf.csv"
} #function write_db_entry()

write_timing_file(){
  {
    printf '%s\n' "Added $TODAY at $SCRIPT_START_TIME:"
    cat "$TMP_TIMING_FILE"
    printf '%s\n' 'Storage size:'
    printf '    %s\n' "$file_size_gb GB"
    printf '    %s\n' "$file_size_mb MB"
    printf '    %s\n' "$file_size_kb KB"
    printf '%s\n' 'System Information:'
    printf '    %s: "%s"\n' 'HOSTNAME' "$HOSTNAME"
    printf '    %s: "%s"\n' 'PLATFORM' "$PLATFORM"
    printf '    %s: "%s"\n' 'CPU_MODEL_NAME' "$CPU_MODEL_NAME"
    printf '    %s: "%s"\n' 'CPU_CACHE_SIZE' "$CPU_CACHE_SIZE"
    printf '    %s: "%s"\n' 'CPU_CORE_COUNT' "$CPU_CORE_COUNT"
    printf '    %s: "%s"\n' 'RAM_TOTAL' "$RAM_TOTAL"
    printf '    %s: "%s"\n' 'RAM_FREE' "$RAM_FREE"
    printf '    %s: "%s"\n' 'RAM_AVAILABLE' "$RAM_AVAILABLE"
    printf '    %s: "%s"\n' 'CALLER' "$CALLER"
    printf '%s\n' 'Code Information:'
    printf '    %s: "%s"\n' 'GIT_BRANCH' "$GIT_BRANCH"
    printf '    %s: "%s"\n' 'GIT_COMMIT' "$GIT_COMMIT"
    printf '    %s: "%s"\n' 'GIT_LATEST_RELEASE' "$GIT_LATEST_RELEASE"
    printf '%s\n' 'Configuration Information:'
    printf '    %s: "%s"\n' 'SIMULATION_LENGTH' "$SIMULATION_LENGTH"
    printf '    %s: "%s"\n' 'TIME_STEP_SIZE' "$TIME_STEP_SIZE"
    printf '    %s: "%s"\n' 'NUMBER_OF_NODES' "$NUMBER_OF_NODES"
    printf '    %s: "%s"\n' 'NUMBER_OF_PROPAGATORS' "$NUMBER_OF_PROPAGATORS"
    printf '    %s: "%s"\n' 'MAX_TAU' "$MAX_TAU"

    printf '\n%s\n' '#---------------------------------------------------------------#'
  } >> "$TIMING_FILE"
} #function write_timing_file()

#Write selected fields from entries that match CONDITION to a file formatted
#as a Markdown table. Called by nf_benchmarks --to-markdown.
#write_to_markdown(){
#  local headings=('Run Time' 'Memory Used' 'CPU' 'Cache Size' 'RAM-Total' 'Length' 'dt' 'Nodes' 'git-commit' )
#  local centred=(':--------:|:-----------:|:---:|:----------:|:---------:|:------:|:---:|:----:|:----------:|')
#  local fields=('resources: 1' 'resources: 3' 'sys_info: 3' 'sys_info: 4' 'sys_info: 6' 'conf: 1' 'conf: 2' 'conf: 3' 'code: 2' )
#
#  #if [[ ! -f "$RESULTS_DIR/benchmarks.md" ]]; then
#  #  #Initialise System Information file -- Markdown.
#  #  {
#  #    printf '|'
#  #    printf '%s |'     'HOSTNAME' 'PLATFORM' 'CPU_MODEL_NAME' 'CPU_CACHE_SIZE' 'CPU_CORE_COUNT' 'RAM_TOTAL' 'RAM_FREE' 'RAM_AVAILABLE' 'CALLER'
#  #    printf '\n%s\n' '|:--------:|:--------:|:--------------:|:--------------:|:--------------:|:---------:|:--------:|:-------------:|:------:|'
#  #  } > "$RESULTS_DIR/benchmarks.md"
#  #fi
#  # #Add an entry to the System Information file -- Markdown table.
#  #{
#  #  printf '|'
#  #  printf '%s |' "$HOSTNAME" "$PLATFORM" "$CPU_MODEL_NAME" "$CPU_CACHE_SIZE" "$CPU_CORE_COUNT" "$RAM_TOTAL" "$RAM_FREE" "$RAM_AVAILABLE" "$CALLER"
#  #  printf '\n'
#  #} >> "$RESULTS_DIR/system_info.md"
#} #write_to_markdown()


#--------------------------------------------------------------#
#-------------------- Begin Main Script -----------------------#
#--------------------------------------------------------------#

# Decide if we are processing a single .conf file or all our benchmarks/*.conf files.
if (( NON_FLAG_ARG_COUNT == 0 )); then
  yesorno='n'
  printf '\n\n'
  printf '%s\n' 'WARNING: You are about to run benchmarking for all .conf'
  printf '    %s\n' 'files in the benchmarks directory. To run benchmarking'
  printf '    %s\n' 'of a specific configuration file, you must specify that'
  printf '    %s\n\n' 'file as an argument.'
  read -r -n1 -p "Do you really want to run all the .conf files in benchmarks? y/(n)>" yesorno
  printf '\n'
  if [[ "$yesorno" != 'y' ]]; then exit 1; fi
  [[ "${NF_BENCH_NO_MAKE,,}" = 'true' ]] || if ! fresh_build; then exit 1; fi
  for config_file in "${SCRIPT_PATH}"/*.conf; do
    if [[ "${NF_BENCH_TO_MEM,,}" = 'true' ]]; then
      "$SCRIPT_PATH/nf_benchmarks" --no-make --to-mem "$config_file"
    else
      "$SCRIPT_PATH/nf_benchmarks" --no-make "$config_file"
    fi
  done
  exit 0
elif (( NON_FLAG_ARG_COUNT == 1 )); then
  [[ -f "$CONFIG_FILE" ]] || { printf 'ERROR: %s\n' "Argument is not a file: '$CONFIG_FILE'"; exit 1; }
  CONFIG_FILE_BASENAME="$(basename "$CONFIG_FILE")"
  if [[ "${NF_BENCH_STORE_OUTPUT,,}" = 'true' ]]; then
    OUTPUT_FILE_BASENAME="${CONFIG_FILE_BASENAME%.*}_${FILE_NAME_NOW}.output"
  else
    OUTPUT_FILE_BASENAME="${CONFIG_FILE_BASENAME%.*}.output"
  fi
  if [[ "${NF_BENCH_TO_MEM,,}" = 'true' ]]; then
    OUTPUT_FILE="$MEM_DIR/$OUTPUT_FILE_BASENAME"
  else
    OUTPUT_FILE="$RESULTS_DIR/$OUTPUT_FILE_BASENAME"
  fi
  TIMING_FILE="$RESULTS_DIR/timing_${CONFIG_FILE_BASENAME%.*}.txt"
else
  printf 'ERROR: %s\n' "${BASH_SOURCE[0]} takes, at most, one .conf file argument."
  exit 1
fi

if [[ "${DEBUG,,}" = 'true' ]]; then
  printf '%s\n' "NEUROFIELD: '$NEUROFIELD'"
  printf '%s\n' "CONFIG_FILE: '$CONFIG_FILE'"
  printf '%s\n' "OUTPUT_FILE: '$OUTPUT_FILE'"
  printf '%s\n' "TIMING_FILE: '$TIMING_FILE'"
  printf '%s\n' "RESULTS_DIR: '$RESULTS_DIR'"
  printf '%s\n' "PWD: '$(pwd)'"
fi

#Gather information relevant to this benchmark run.
if ! gather_system_info; then exit 1; fi
if ! gather_code_info; then exit 1; fi
if ! gather_conf_info; then exit 1; fi

#Unless we have explicitly been told not to, rebuild neurofield.
[[ "${NF_BENCH_NO_MAKE,,}" = 'true' ]] || if ! fresh_build; then exit 1; fi

if ! TMP_TIMING_FILE="$(mktemp "$TMP_DIR"/nf_timing-XXXX)"; then
  printf '%s\n' "ERROR: Failed to create temporary timing file."
  exit 1
fi

#Finally, do the actual benchmark run:
/usr/bin/time -v "$NEUROFIELD" -i "$CONFIG_FILE" -o "$OUTPUT_FILE" 2>> "$TMP_TIMING_FILE"

#Collect important resource usage info into variables
file_size="$(wc --bytes < "$OUTPUT_FILE")"
file_size_gb=$((file_size/(1048576*1024))) # in GB
file_size_mb=$((file_size/(1048576)))      # in MB
file_size_kb=$((file_size/(1024)))         # in KB

USER_TIME="$(grep 'User time' "$TMP_TIMING_FILE")"
USER_TIME_UNITS="$(grep --only-matching '(.*)' <<< "$USER_TIME" | tr -d '()')"
USER_TIME="$(grep --only-matching '[[:digit:]]*\.\?[[:digit:]]*' <<< "$USER_TIME")"

MAX_RES_SIZE="$(grep 'Maximum resident set size' "$TMP_TIMING_FILE")"
MAX_RES_SIZE_UNITS="$(grep --only-matching '(.*)' <<< "$MAX_RES_SIZE" | tr -d '()')"
MAX_RES_SIZE="$(grep --only-matching  '[[:digit:]]*' <<< "$MAX_RES_SIZE")"

#Write benchmark information to files:
write_timing_file
write_db_entry

#Clean-up
rm -f "$TMP_TIMING_FILE"
[[ "${NF_BENCH_TO_MEM,,}" = 'true' ]] && mv "$OUTPUT_FILE" "$RESULTS_DIR"
